[{"/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/index.js":"1","/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/use-postprocessing.js":"2","/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/reflector.js":"3","/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/reflector-material.js":"4"},{"size":3684,"mtime":1609330220065,"results":"5","hashOfConfig":"6"},{"size":2392,"mtime":1609329418057,"results":"7","hashOfConfig":"6"},{"size":6535,"mtime":1609329357485,"results":"8","hashOfConfig":"6"},{"size":2276,"mtime":1609322433298,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"ceuim0",{"filePath":"12","messages":"13","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"14","messages":"15","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20","usedDeprecatedRules":"17"},"/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/index.js",[],"/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/use-postprocessing.js",["21"],"/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/reflector.js",["22","23","24"],"import { useCallback, useMemo, useState } from \"react\";\nimport {\n  Fog,\n  LinearFilter,\n  MathUtils,\n  Matrix4,\n  PerspectiveCamera,\n  Plane,\n  RGBFormat,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  RGBADepthPacking\n} from \"three\";\nimport { SavePass, RenderPass, LambdaPass, DepthPass,EffectPass, DepthOfFieldEffect, BlurPass } from \"postprocessing\";\nimport { useResource, useThree } from \"react-three-fiber\";\n\nexport function useReflector({ textureWidth, textureHeight, clipBias }) {\n  const meshRef = useResource();\n  const [reflectorPlane] = useState(() => new Plane());\n  const [normal] = useState(() => new Vector3());\n  const [reflectorWorldPosition] = useState(() => new Vector3());\n  const [cameraWorldPosition] = useState(() => new Vector3());\n  const [rotationMatrix] = useState(() => new Matrix4());\n  const [lookAtPosition] = useState(() => new Vector3(0, 0, -1));\n  const [clipPlane] = useState(() => new Vector4());\n  const [view] = useState(() => new Vector3());\n  const [target] = useState(() => new Vector3());\n  const [q] = useState(() => new Vector4());\n  const [textureMatrix] = useState(() => new Matrix4());\n  const [virtualCamera] = useState(() => new PerspectiveCamera());\n  const { gl: renderer, scene, camera } = useThree();\n\n  const beforeRender = useCallback(\n    function beforeRender() {\n      if (!meshRef.current) return;\n      meshRef.current.visible = false;\n      reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n\n      rotationMatrix.extractRotation(meshRef.current.matrixWorld);\n\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away\n      if (view.dot(normal) > 0) return;\n\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n\n      rotationMatrix.extractRotation(camera.matrixWorld);\n\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Update the texture matrix\n      textureMatrix.set(\n        0.5,\n        0.0,\n        0.0,\n        0.5,\n        0.0,\n        0.5,\n        0.0,\n        0.5,\n        0.0,\n        0.0,\n        0.5,\n        0.5,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n      );\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(meshRef.current.matrixWorld);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(\n        normal,\n        reflectorWorldPosition\n      );\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n\n      clipPlane.set(\n        reflectorPlane.normal.x,\n        reflectorPlane.normal.y,\n        reflectorPlane.normal.z,\n        reflectorPlane.constant\n      );\n\n      const projectionMatrix = virtualCamera.projectionMatrix;\n\n      q.x =\n        (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) /\n        projectionMatrix.elements[0];\n      q.y =\n        (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) /\n        projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w =\n        (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n    },\n    [\n      clipBias,\n      meshRef,\n      camera,\n      reflectorPlane,\n      normal,\n      reflectorWorldPosition,\n      cameraWorldPosition,\n      rotationMatrix,\n      lookAtPosition,\n      clipPlane,\n      view,\n      target,\n      q,\n      textureMatrix,\n      virtualCamera,\n    ]\n  );\n\n  function afterRender() {\n    if (!meshRef.current) return;\n    meshRef.current.visible = true;\n  }\n\n  const {\n    renderPass,\n    savePass,\n    depthPass,\n    blurPass,\n    lambdaPassBefore,\n    lambdaPassAfter,\n  } = useMemo(() => {\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBFormat,\n    };\n    const renderTarget = new WebGLRenderTarget(\n      textureWidth,\n      textureHeight,\n      parameters\n    );\n    renderTarget.texture.encoding = renderer.outputEncoding;\n\n    if (\n      !MathUtils.isPowerOfTwo(textureWidth) ||\n      !MathUtils.isPowerOfTwo(textureHeight)\n    ) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    const renderPass = new RenderPass(scene, virtualCamera);\n    // const blurPass = new BlurPass();\n    // blurPass.width = 2000;\n    // blurPass.height = 2000;\n    \n    const depthPass = new DepthPass(scene, virtualCamera);\n    const dof = new DepthOfFieldEffect(virtualCamera, {\n      focusDistance: 0.2,\n      focalLength: 1.0,\n      bokehScale: 4.0,\n    })\n    const blurPass = new EffectPass(virtualCamera, dof)\n    blurPass.setDepthTexture(depthPass.texture, RGBADepthPacking);\n\n    const savePass = new SavePass(renderTarget);\n    const lambdaPassBefore = new LambdaPass(beforeRender);\n    const lambdaPassAfter = new LambdaPass(afterRender);\n    return {\n      renderPass,\n      savePass,\n      lambdaPassBefore,\n      lambdaPassAfter,\n      blurPass,\n      depthPass\n    };\n  }, [\n    textureWidth,\n    textureHeight,\n    beforeRender,\n    virtualCamera,\n    scene,\n    renderer.outputEncoding,\n  ]);\n\n  return [\n    meshRef,\n    textureMatrix,\n    renderPass,\n    savePass,\n    lambdaPassBefore,\n    lambdaPassAfter,\n    blurPass,\n    depthPass\n  ];\n}\n",["25","26"],"/Users/marcoludovicoperego/Downloads/oa-proj-cannon-lol-forked/src/reflector-material.js",["27","28"],"import React, { useState } from \"react\";\nimport { Matrix4, MeshPhysicalMaterial, Texture } from \"three\";\n\nclass ReflectorMaterialImpl extends MeshPhysicalMaterial {\n  _tDiffuse;\n  _textureMatrix;\n  constructor(parameters = {}) {\n    super(parameters);\n    this.setValues(parameters);\n    this._tDiffuse = { value: null };\n    this._textureMatrix = { value: null };\n  }\n\n  onBeforeCompile(shader) {\n    shader.uniforms.tDiffuse = this._tDiffuse;\n    shader.uniforms.textureMatrix = this._textureMatrix;\n\n    shader.vertexShader = `\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n     \n      ${shader.vertexShader}\n    `;\n    shader.vertexShader = shader.vertexShader.replace(\n      \"#include <project_vertex>\",\n      `\n        #include <project_vertex>\n\t    my_vUv = textureMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        `\n    );\n\n    shader.fragmentShader = `\n        uniform sampler2D tDiffuse;\n        varying vec4 my_vUv;\n\n        float blendAdd(float base, float blend) {\n            return min(base+blend,1.0);\n        }\n\n        vec3 blendAdd(vec3 base, vec3 blend) {\n            return min(base+blend,vec3(1.0));\n        }\n\n        vec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n            return (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n        }\n        ${shader.fragmentShader}\n    `;\n    shader.fragmentShader = shader.fragmentShader.replace(\n      \"#include <map_fragment>\",\n      `\n        #include <map_fragment>\n        vec4 base = texture2DProj( tDiffuse, my_vUv );\n        vec4 myTexelRoughness = texture2D( roughnessMap, vUv );\n        base *= 1.0 - myTexelRoughness.r;\n        diffuseColor.rgb += 0.1 * base.rgb; //blendAdd( base.rgb, diffuseColor.rgb, 0.0);\n      `\n    );\n  }\n\n  get tDiffuse() {\n    return this._tDiffuse.value;\n  }\n\n  set tDiffuse(v) {\n    this._tDiffuse.value = v;\n  }\n  get textureMatrix() {\n    return this._textureMatrix.value;\n  }\n\n  set textureMatrix(v) {\n    this._textureMatrix.value = v;\n  }\n}\n\nexport const ReflectorMaterial = React.forwardRef((props, ref) => {\n  const [material] = useState(() => new ReflectorMaterialImpl());\n  return <primitive object={material} ref={ref} attach=\"material\" {...props} />;\n});\n",{"ruleId":"29","severity":1,"message":"30","line":24,"column":11,"nodeType":"31","messageId":"32","endLine":24,"endColumn":21},{"ruleId":"29","severity":1,"message":"33","line":3,"column":3,"nodeType":"31","messageId":"32","endLine":3,"endColumn":6},{"ruleId":"29","severity":1,"message":"34","line":15,"column":86,"nodeType":"31","messageId":"32","endLine":15,"endColumn":94},{"ruleId":"35","severity":1,"message":"36","line":210,"column":6,"nodeType":"37","endLine":217,"endColumn":4,"suggestions":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","replacedBy":"42"},{"ruleId":"29","severity":1,"message":"43","line":2,"column":10,"nodeType":"31","messageId":"32","endLine":2,"endColumn":17},{"ruleId":"29","severity":1,"message":"44","line":2,"column":41,"nodeType":"31","messageId":"32","endLine":2,"endColumn":48},"no-unused-vars","'anisotropy' is assigned a value but never used.","Identifier","unusedVar","'Fog' is defined but never used.","'BlurPass' is defined but never used.","react-hooks/exhaustive-deps","React Hook useMemo has a missing dependency: 'afterRender'. Either include it or remove the dependency array.","ArrayExpression",["45"],"no-native-reassign",["46"],"no-negated-in-lhs",["47"],"'Matrix4' is defined but never used.","'Texture' is defined but never used.",{"desc":"48","fix":"49"},"no-global-assign","no-unsafe-negation","Update the dependencies array to be: [textureWidth, textureHeight, renderer.outputEncoding, scene, virtualCamera, beforeRender, afterRender]",{"range":"50","text":"51"},[6244,6363],"[textureWidth, textureHeight, renderer.outputEncoding, scene, virtualCamera, beforeRender, afterRender]"]